## ---------------------------------------------------------------------------------------------------------- #
""" \package allocationMaster
    \brief   This script automates a few tasks regarding processing of inventory files generated by the
             allocation master spreadsheet. First is converting two of the xlsx files to csv format, and one
             to txt. Next is sending two of the xlsx files by email, and the third stage is uploading the
             remainder to various inventory tracking portals.

"""
import argparse
import csv
import ftplib
import openpyxl
import os
import smtplib
import ssl
import time

from email                import encoders
from email.mime.base      import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.text      import MIMEText
from selenium.common.exceptions    import NoSuchElementException
from selenium.common.exceptions    import TimeoutException
from selenium.common.exceptions    import WebDriverException
from selenium.webdriver.common.by  import By
from selenium.webdriver.support    import expected_conditions as ec
from selenium.webdriver.support.ui import WebDriverWait
from selenium import webdriver
from smtplib  import SMTPException


## ---------------------------------------------------------------------------------------------------------- #
# Global definitions
fileNames = ['Target', 'Fanatics', 'HSN', 'Groupon', 'Hibbits', 'ShopHQ', 'BBB', 'Belk']
filePaths = dict.fromkeys(fileNames, '')

testEmailAddress = ''

browser = None

radialLinks = ('//*[@id="LeftMenu2"]/table/tbody/tr[18]/td/a', '//*[@id="LeftMenu2"]/table/tbody/tr[19]/td/a')

# URL tuples: The first url is the login page, and the second is the upload file page or a tuple of links (see 'uploadFile' comments below)
loginVendor  = ('https://www.vendorbridge.com/default.aspx', 'https://www.vendorbridge.com/Products/UploadInventory.aspx')
loginGroupon = ('https://www.groupon.com/goods-gateway/auth/login', 'https://www.groupon.com/goods-gateway/files')
loginRadial  = ('https://vn.gsipartners.com', radialLinks)
loginComHub  = ('https://apps.commercehub.com/account/login?service=https://dsm.commercehub.com/dsm/shiro-cas', 'https://dsm.commercehub.com/dsm/gotoUploadFile.do')

# XPaths for various DOM elements (see 'uploadFile' comments below)
radialXPath = ('//*[@id="Logon"]/form/table/tbody/tr[1]/td[2]/input', '//*[@id="Logon"]/form/table/tbody/tr[2]/td[2]/input', '//*[@id="Logon"]/form/table/tbody/tr[2]/td[5]/input', '/html/body/table/tbody/tr[3]/td[3]/table/tbody/tr[2]/td[2]/form/table/tbody/tr[4]/td[2]/input')
comHubXPath = ('//*[@id="username"]', '//*[@id="password"]', '//*[@id="fm1"]/input[5]', '//button[text()="Upload"]')
groupoXPath = ('//*[@id="email"]', '//*[@id="password"]', '//*[@id="login-button"]', '')

## ---------------------------------------------------------------------------------------------------------- #
# Class definitions
class ImplicitFTP_TLS(ftplib.FTP_TLS):
    """FTP_TLS subclass that automatically wraps sockets in SSL to support implicit FTPS."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._sock = None

    @property
    def sock(self):
        """Return the socket."""
        return self._sock

    @sock.setter
    def sock(self, value):
        """When modifying the socket, ensure that it is ssl wrapped."""
        if value is not None and not isinstance(value, ssl.SSLSocket):
            value = self.context.wrap_socket(value)
        self._sock = value

## ---------------------------------------------------------------------------------------------------------- #
# Function definitions
def exportToText(file, ext):
    if file == '' or file.endswith('.csv'):
        return False
    
    book  = openpyxl.load_workbook(file)
    sheet = book.active

    with open(os.path.splitext(os.path.basename(file))[0] + ext , 'w', newline="") as f:
        csvFile = csv.writer(f, delimiter=',' if ext == '.csv' else '\t')
        for row in sheet.rows:
            csvFile.writerow([cell.value for cell in row])
    
    return True

def ftpTransfer(file):
    if file == '':
        return False
    
    FTP_SERVER = 'hsnedi.hsn.net'
    FTP_PORT   = 990
    FTP_USER   = 'ftps427897'
    FTP_PASS   = '427897Ftps'

    try:
        ftpConn = ImplicitFTP_TLS()
        res = ftpConn.connect(FTP_SERVER, FTP_PORT)
        #ftpConn.auth()
        res = ftpConn.login(FTP_USER, FTP_PASS)
        res = ftpConn.prot_p()

        f = open(os.path.join(os.getcwd(), file), 'rb')

        res = ftpConn.storbinary('STOR ' + file, f)
        ftpConn.quit()
        ftpConn.close()

        f.close()
    except ftplib.all_errors:
        print('Uh-oh... An error has occurred.')
        return False
    
    return True



def sendEmail(file, subject):
    if file == '':
        return False
    
    SMTP_SERVER   = 'smtp.gmail.com'
    SMTP_PORT     = 587
    SMTP_USER     = 'joshualastva@gmail.com'
    SMTP_PASSWORD = '603550duke'
    EMAIL_FROM    = 'Joshua Last <joshualastva@gmail.com>'
    EMAIL_TO      = 'production@actdata.com' if testEmailAddress == '' else testEmailAddress
    EMAIL_BCC     = 'j632600@yahoo.com'
    EMAIL_SUBJECT = subject

    msg = MIMEMultipart()

    msg['Subject'] = EMAIL_SUBJECT
    msg['From']    = EMAIL_FROM 
    msg['To']      = EMAIL_TO
    msg['Bcc']     = EMAIL_BCC

    attachment = MIMEBase('application', 'vnd.ms-excel')
    attachment.set_payload(open(file, 'rb').read())
    encoders.encode_base64(attachment)
    attachment.add_header('Content-Disposition', 'attachment', filename=file)
    msg.attach(attachment)

    try:
        mail = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
        mail.set_debuglevel(True)
        mail.starttls()
        mail.login(SMTP_USER, SMTP_PASSWORD)
        res = mail.sendmail(EMAIL_FROM, EMAIL_TO, msg.as_string())
        mail.quit()
    except SMTPException:
        print('Uh-oh... An error has occurred.')
        return False
    
    return True


def uploadFile(filePaths,        # path to file(s) to upload
               loginPage,        # url to the login page
               username,         # username string
               password,         # password string
               xPaths,           # xpaths to the following DOM elements: username and password fields, login submit button, file upload submit button
               uploadPage,       # url to the upload page, or xpaths of links navigating to the upload page (some websites redirect back to login page if you try a url)
               loginElement,     # xpath to a DOM element present only after successful login
               filePathElement   # xpath to the file path input element
    ):
    global browser

    try:
        # 1) open login page
        browser.get(loginPage)

        # 2) locate username and password fields, fill in information
        browser.find_element_by_xpath(xPaths[0]).send_keys(username)
        browser.find_element_by_xpath(xPaths[1]).send_keys(password)
        browser.find_element_by_xpath(xPaths[2]).click()
    
        # 3) find an element present after successful login
        isRefreshed = False
        while not isRefreshed:
            try:
                pageItem = browser.find_element_by_xpath(loginElement)
            except NoSuchElementException:
                time.sleep(1)
                continue
            isRefreshed = True
    
        # 4) navigate to upload page
        #    A tuple is giving in the case where trying to enter the upload page URL is re-directed back
        #    to the login screen. The tuple consists of xpaths for links navigating to the upload page instead.
        if type(uploadPage) == tuple:
            for link in uploadPage:
                browser.find_element_by_xpath(link).click()
                time.sleep(1)
        else:
            browser.get(uploadPage)
    
        # 5) locate file upload field, fill in path
        #    A for loop is used below to upload multiple files passed as the argument for filepaths. If only a
        #    single filepath is passed, the string is converted to a tuple with a blank entry so the for loop
        #    works properly on the whole string, rather than trying to iterate over each letter.
        numFilesUp = 0
        if type(filePaths) != tuple:
            filePaths = (filePaths, '')
        
        try:
            fileElement = WebDriverWait(browser, 5).until(ec.presence_of_element_located((By.XPATH, filePathElement)))
        except TimeoutException:
            print('Timeout waiting for upload page.')
            return numFilesUp
        
        # Commerce hub requires uploading multiple files which causes the xpaths to change. Therefore, class name
        # is used to find the input element each time. There are two file upload fields on the page, so index value
        # '1' is used to grab the second one. All other pages simply use the filePathElement found above, and assign
        # the file path string to its value. One website doesn't require clicking a submit button, so that is also
        # checked.
        for file in filePaths:
            if file == '':
                continue
            if loginPage == loginComHub[0]:
                fileElement = browser.find_elements_by_class_name("css-filenamecontainer-1odnfu4")
                browser.execute_script("arguments[0].innerText = '%s'" % file, fileElement[1])
                browser.execute_script("arguments[0].title = '%s'" % file, fileElement[1])
                browser.find_elements_by_class_name("css-glamorous-input--1wmgl9x")[1].send_keys(os.path.join(os.getcwd(), file))
                # 6) submit
                if xPaths[3] != '':
                    browser.find_elements_by_xpath(xPaths[3])[1].click()
                time.sleep(1)
            else:
                fileElement.send_keys(os.path.join(os.getcwd(), file))
                # 6) submit
                if xPaths[3] != '':
                    browser.find_element_by_xpath(xPaths[3]).click()
                time.sleep(3)
        
            numFilesUp += 1
    except WebDriverException:
        print('Woops! Something went wrong.')
        return numFilesUp

    return numFilesUp

## ---------------------------------------------------------------------------------------------------------- #
# Main function
def Main():
    global testEmailAddress
    global browser

    parser = argparse.ArgumentParser()
    parser.add_argument('--emailTest', action = 'store_true', help = 'Provide alternate email to send for testing.')

    args = parser.parse_args()

    if args.emailTest:
        testEmailAddress = input('Enter your test email address: ')

    # pre-step) Get file paths for each exported spreadsheet
    for file in os.listdir(os.getcwd()):
        if file.endswith('.xlsx') or file.endswith('.xls') or file.endswith('.csv'):
            if file.startswith('Target'):
                filePaths['Target'] = file
            elif file.startswith('Fanatics'):
                filePaths['Fanatics'] = file
            elif file.startswith('HSN'):
                filePaths['HSN'] = file
            elif file.startswith('Groupon'):
                filePaths['Groupon'] = file
            elif file.startswith('Hibbits'):
                filePaths['Hibbits'] = file
            elif file.startswith('ShopHQ'):
                filePaths['ShopHQ'] = file
            elif file.startswith('BBB'):
                filePaths['BBB'] = file
            elif file.startswith('Belk'):
                filePaths['Belk'] = file
            elif file.startswith('Walmart'):
                filePaths['Walmart'] = file

    # 1) convert three files to csv/txt
    print('Conversion step...')
    numCon = 0
    if exportToText(filePaths['Groupon'], '.csv'):
        numCon += 1
        fileName = filePaths['Groupon']
        os.remove(filePaths['Groupon'])
        filePaths['Groupon'] = os.path.splitext(os.path.basename(fileName))[0] + '.csv'
    if exportToText(filePaths['Hibbits'], '.csv'):
        numCon += 1
        fileName = filePaths['Hibbits']
        os.remove(filePaths['Hibbits'])
        filePaths['Hibbits'] = os.path.splitext(os.path.basename(fileName))[0] + '.csv'
    print(f'Done. Converted {numCon} file(s)')
    
    # 2) email two files as is
    print('Email step...')
    numEmail = 0
    if sendEmail(filePaths['Target'], 'Target'):
        numEmail += 1
    if sendEmail(filePaths['Fanatics'], 'Fanatics'):
        numEmail += 1
    print(f'Done. Sent {numEmail} email(s)')

    # 3) upload the rest to their respective websites
    print('File upload step...')
    browser = webdriver.Chrome()
    numFilesUp = 0
    numFilesUp += uploadFile((filePaths['ShopHQ'], filePaths['BBB'], filePaths['Belk']), loginComHub[0], 'joshlast', '603550Duke5!', comHubXPath, loginComHub[1], '//*[@id="chub-navi-user-name"]', '//*[@id="pageParent"]/tbody/tr[6]/td/table/tbody/tr[3]/td/table/tbody/tr[2]/td/table/tbody/tr/td[2]/form/div/div/div[1]/span')
    numFilesUp += uploadFile(filePaths['Hibbits'], loginRadial[0], 'HBT_Southfield', 'Welcome72', radialXPath, loginRadial[1], '/html/body/table/tbody/tr[2]/td/table/tbody/tr[2]/td/table/tbody/tr/td[2]/table/tbody/tr/td[4]/a', '/html/body/table/tbody/tr[3]/td[3]/table/tbody/tr[2]/td[2]/form/table/tbody/tr[2]/td[2]/input')
    numFilesUp += uploadFile((filePaths['Groupon']), loginGroupon[0], 'lazar.porter@gmail.com', '603550buff', groupoXPath, loginGroupon[1], '//*[@id="logout"]', '//*[@id="file-browser"]')
    print(f'Done. Uploaded {numFilesUp} file(s)')
    browser.close()

    # 4) ftp transfer remaining files
    print('FTP transfer step...')
    numFilesFtpd = 0
    if ftpTransfer(filePaths['HSN']):
        numFilesFtpd += 1
    print(f'Done. Transferred {numFilesFtpd} file(s)')

    # 5) remove all files
    print('Removing files...')
    numFilesRemoved = len(filePaths)
    for file in filePaths:
        os.remove(file)
    print(f'Done. Removed {numFilesRemoved} file(s)')

if __name__ == '__main__':
    Main()

